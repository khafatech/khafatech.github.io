((3) 0 () 2 ((p+ #"/home/mushi/blog/_src/posts/2019-02-18-an-old-idea.md" . unix) (p+ #"/home/mushi/blog/_src/posts/2016-02-13-learning-haskell.md" . unix)) () (h ! (equal) ((p+ #"/home/mushi/blog/_src/posts/2016-02-13-learning-haskell.md" . unix) f post (u . "My experience learning Haskell") (? . 1) 1561605584 (p+ #"/home/mushi/blog/blog/2019/05/03/my-experience-learning-haskell/index.html" . unix) (u . "/blog/2019/05/03/my-experience-learning-haskell/") (u . "2019-05-03T19:27:14") (? . 0) #f (c (u . "haskell") c (u . "functionalprogramming")) (u . "\n<p>tl;dr Haskell will help you in other languages even if you don&rsquo;t use it.</p>\n\n<p>I&rsquo;ve always been fascinated by the Haskell code I&rsquo;ve seen <strong>[1]</strong>, and I tried <a href=\"http://learnyouahaskell.com\">learning Haskell</a> briefly in 2010 and when configuring Xmonad. In 2015, I started <a href=\"https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours\">learning Haskell seriously</a> by writing a significant piece of software, a Scheme interpreter, with the help of a tutorial. After few months in, I found that my style of programming in Python has improved somewhat. I discovered some patterns where functions returning functions greatly reduce duplication. In fact, functions returning functions are one type of the decorator syntax. Also, separating side-effect producing functions from pure functions was a good practice - it lead to less bugs and more testable code. More testable because of the lesser reliance on an external environment. Now with type hints in Python 3, one can also benefit from defining types and using algebraic data types <a href=\"https://docs.python.org/3/library/typing.html#newtype\">NewType</a>. Python&rsquo;s type hints are nowhere near as mature as Haskell&rsquo;s type system though, and their optional nature in Python changes the experience of using them.</p>\n\n<p><strong>[1]</strong> I should note that some of the very succinct and elegant examples are not accurate, such as the <a href=\"https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\">Sieve of Eratosthenes</a> two-liner:</p>\n\n<div class=\"brush: Haskell\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span></span><span class=\"nf\">primes</span> <span class=\"ow\">=</span> <span class=\"n\">sieve</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">..</span><span class=\"p\">]</span>\n<span class=\"nf\">sieve</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"kt\">:</span> <span class=\"n\">xs</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">p</span> <span class=\"kt\">:</span> <span class=\"n\">sieve</span> <span class=\"p\">[</span><span class=\"n\">x</span> <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span><span class=\"err\">−</span> <span class=\"n\">xs</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"p\">`</span><span class=\"n\">mod</span><span class=\"p\">`</span> <span class=\"n\">p</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h2 id=\"how-is-haskell-different-from-lispracketclojure\">How is Haskell different from lisp/racket/clojure?</h2>\n\n<p>Haskell belongs to family of functional languages that are statically typed with <a href=\"https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system\">Hindley–Milner type system</a>.</p>\n\n<p>Besides the ambiguity of calling a language <em>functional</em>. (Is Javascript functional?)</p>\n\n<p>A couple of differences from the classic functional languages:</p>\n\n<ul>\n <li>A superficial difference: Haskell isn&rsquo;t littered with parenthesis or the <em>s-expression</em> format</li>\n <li>Haskell is strongly and statically typed, with type inference. The Hinley-Milner type system is arguably one of the most advanced type systems in any language. A monad is a typeclass.</li>\n <li>It&rsquo;s purely functional, meaning functions always return the same value, functions can&rsquo;t produce side effects, and variables are immutable. Some languages related to Haskell like SML, OCaml and F# achieve different degrees of these.</li></ul>\n\n<p>&gt;&gt;&gt;&gt;&gt;&gt; b338feaa4ad3eebe43f972fa8966a948239fd22e</p>\n\n<h2 id=\"dont-fear-the-monad\">Don&rsquo;t fear the monad</h2>\n\n<p>One major feature of Haskell is its monads. There&rsquo;s a joke that once one understands the monad, you loose the ability to explain it to others.</p>\n\n<p>It is based on <a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">relatively simple concepts</a>.</p>\n\n<p>My view is that it&rsquo;s a typeclass that can be used to chain function calls, and encapsulate other values. There&rsquo;s also some syntactic sugar around monad chaining built into Haskell&rsquo;s syntax, like the <a href=\"https://en.wikibooks.org/wiki/Haskell/do_notation\"><code>do</code></a> notation and list comprehension.</p>\n\n<p>It&rsquo;s a pretty big deal - it allows most parts of Haskell to remain purely functional while allowing things like IO. It does this by deferring the read/write actions to the runtime. It&rsquo;s more subtle than this, but the idea is that Haskell code that manipulates <em>instructions to perform IO</em> can be purely functional.</p>\n\n<h2 id=\"some-misconceptions-and-myths\">Some misconceptions and myths</h2>\n\n<ul>\n <li>\n  <p><strong>There are no runtime errors</strong>. Runtime errors are still possible. For example, the <a href=\"https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:error\">error</a> function that can typematch to any function and simply exits.</p></li>\n <li>\n  <p><strong>You need to be a genius with a Computer Science PhD to learn/use Haskell</strong>. It&rsquo;s not true. The core language is fairly simple. What&rsquo;s hard about learning Haskell are all the habits and mental model of what a programming language is. Coming from a procedural or C-like language background, a lot of concepts would seem alien or weird. Haskell does come from an academic background, and it shows in a lot of the terminology, but since then it has escaped and seen uses all over the place. For instance, a Haskell music livecoding environment called <a href=\"http://tidalcycles.org\">TidalCycles</a> is used by artists and musicians who don&rsquo;t know programming, let alone Haskell. Still, it&rsquo;s syntactically correct Haskell code executed in GHCi.</p></li></ul>\n\n<h2 id=\"references\">References</h2>\n\n<p><a href=\"https://gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php\">In-depth: Functional programming in C++</a> by John Carmack</p>") #f (u . "\n<p>tl;dr Haskell will help you in other languages even if you don&rsquo;t use it.</p>\n\n<p>I&rsquo;ve always been fascinated by the Haskell code I&rsquo;ve seen <strong>[1]</strong>, and I tried <a href=\"http://learnyouahaskell.com\">learning Haskell</a> briefly in 2010 and when configuring Xmonad. In 2015, I started <a href=\"https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours\">learning Haskell seriously</a> by writing a significant piece of software, a Scheme interpreter, with the help of a tutorial. After few months in, I found that my style of programming in Python has improved somewhat. I discovered some patterns where functions returning functions greatly reduce duplication. In fact, functions returning functions are one type of the decorator syntax. Also, separating side-effect producing functions from pure functions was a good practice - it lead to less bugs and more testable code. More testable because of the lesser reliance on an external environment. Now with type hints in Python 3, one can also benefit from defining types and using algebraic data types <a href=\"https://docs.python.org/3/library/typing.html#newtype\">NewType</a>. Python&rsquo;s type hints are nowhere near as mature as Haskell&rsquo;s type system though, and their optional nature in Python changes the experience of using them.</p>\n\n<p><strong>[1]</strong> I should note that some of the very succinct and elegant examples are not accurate, such as the <a href=\"https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\">Sieve of Eratosthenes</a> two-liner:</p>\n\n<div class=\"brush: Haskell\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span></span><span class=\"nf\">primes</span> <span class=\"ow\">=</span> <span class=\"n\">sieve</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">..</span><span class=\"p\">]</span>\n<span class=\"nf\">sieve</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"kt\">:</span> <span class=\"n\">xs</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">p</span> <span class=\"kt\">:</span> <span class=\"n\">sieve</span> <span class=\"p\">[</span><span class=\"n\">x</span> <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span><span class=\"err\">−</span> <span class=\"n\">xs</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"p\">`</span><span class=\"n\">mod</span><span class=\"p\">`</span> <span class=\"n\">p</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h2 id=\"how-is-haskell-different-from-lispracketclojure\">How is Haskell different from lisp/racket/clojure?</h2>\n\n<p>Haskell belongs to family of functional languages that are statically typed with <a href=\"https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system\">Hindley–Milner type system</a>.</p>\n\n<p>Besides the ambiguity of calling a language <em>functional</em>. (Is Javascript functional?)</p>\n\n<p>A couple of differences from the classic functional languages:</p>\n\n<ul>\n <li>A superficial difference: Haskell isn&rsquo;t littered with parenthesis or the <em>s-expression</em> format</li>\n <li>Haskell is strongly and statically typed, with type inference. The Hinley-Milner type system is arguably one of the most advanced type systems in any language. A monad is a typeclass.</li>\n <li>It&rsquo;s purely functional, meaning functions always return the same value, functions can&rsquo;t produce side effects, and variables are immutable. Some languages related to Haskell like SML, OCaml and F# achieve different degrees of these.</li></ul>\n\n<p>&gt;&gt;&gt;&gt;&gt;&gt; b338feaa4ad3eebe43f972fa8966a948239fd22e</p>\n\n<h2 id=\"dont-fear-the-monad\">Don&rsquo;t fear the monad</h2>\n\n<p>One major feature of Haskell is its monads. There&rsquo;s a joke that once one understands the monad, you loose the ability to explain it to others.</p>\n\n<p>It is based on <a href=\"http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">relatively simple concepts</a>.</p>\n\n<p>My view is that it&rsquo;s a typeclass that can be used to chain function calls, and encapsulate other values. There&rsquo;s also some syntactic sugar around monad chaining built into Haskell&rsquo;s syntax, like the <a href=\"https://en.wikibooks.org/wiki/Haskell/do_notation\"><code>do</code></a> notation and list comprehension.</p>\n\n<p>It&rsquo;s a pretty big deal - it allows most parts of Haskell to remain purely functional while allowing things like IO. It does this by deferring the read/write actions to the runtime. It&rsquo;s more subtle than this, but the idea is that Haskell code that manipulates <em>instructions to perform IO</em> can be purely functional.</p>\n\n<h2 id=\"some-misconceptions-and-myths\">Some misconceptions and myths</h2>\n\n<ul>\n <li>\n  <p><strong>There are no runtime errors</strong>. Runtime errors are still possible. For example, the <a href=\"https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:error\">error</a> function that can typematch to any function and simply exits.</p></li>\n <li>\n  <p><strong>You need to be a genius with a Computer Science PhD to learn/use Haskell</strong>. It&rsquo;s not true. The core language is fairly simple. What&rsquo;s hard about learning Haskell are all the habits and mental model of what a programming language is. Coming from a procedural or C-like language background, a lot of concepts would seem alien or weird. Haskell does come from an academic background, and it shows in a lot of the terminology, but since then it has escaped and seen uses all over the place. For instance, a Haskell music livecoding environment called <a href=\"http://tidalcycles.org\">TidalCycles</a> is used by artists and musicians who don&rsquo;t know programming, let alone Haskell. Still, it&rsquo;s syntactically correct Haskell code executed in GHCi.</p></li></ul>\n\n<h2 id=\"references\">References</h2>\n\n<p><a href=\"https://gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php\">In-depth: Functional programming in C++</a> by John Carmack</p>")) ((p+ #"/home/mushi/blog/_src/posts/2019-02-18-an-old-idea.md" . unix) f post (u . "An old IDEA") (? . 0) 1561605216 (p+ #"/home/mushi/blog/blog/2019/02/18/an-old-idea/index.html" . unix) (u . "/blog/2019/02/18/an-old-idea/") (u . "2019-02-18T17:33:20") #f (? . 1) (c (u . "security") c (u . "encryption")) (u . "\n<p>Spoiler alert: I didn&rsquo;t find the password.</p>\n\n<p>Around 2002, I came across a tool that encrypts and decrypts files using the IDEA cipher. <a href=\"https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm\">IDEA</a> was created in 1991 by James Massey Xuejia Lai, and it seems still relatively secure. It&rsquo;s still used in a recent version of opengpg.</p>\n\n<p>I had encrypted few zip files using this, in 2002 and 2003. (Nothing serious, just wanted to try out encrypting things.) However, I forgot the passwords.</p>\n\n<p>Looking at the implementation, it says it uses a maximum of 8 characters for a passphrase, which is about half of IDEA&rsquo;s 128-bit keylength (not counting non-ascii characters.)</p>\n\n<p>It was a tool for DOS in 16-bit mode.</p>\n\n<p>Given this limitation, is bruteforcing a password possible? If I used only lowercase letters for the password, the number of passwords to try would be <code>26^8 = 208,827,064,576</code>, or about 200 billion combinations. Alphanumeric combinations would be <code>(26*2 + 10)^8 = 218,340,105,584,896</code>, or about 218 trillion. Some simple math can lead us to an estimate of the time to go through the search space. It depends on the elements and elements/s.</p>\n\n<p>One challenge with finding the correct decryption password is there&rsquo;s no easy way of making sure we hae the correct password. The way this idea program worked was to only encrypt/decrypt fixed blocks, with no integrity checking. If we decrypt a file with the wrong password, it would output random data. So one way to find the correct password is to find a pattern in the output if we know what the output would contain. Since it was a zip file, a zip file has a known header in the first block (16 bytes).</p>\n\n<p>I modified the main file to read words from a wordlist, decrypt the first block, and test if it&rsquo;s a zip header. Instead of parallizing the solution in C, I wrote simple bash scripts to run it parallelly after splitting the wordlist into 4, the number of cores I have. I was able to process 700k passwords/s. I wasn&rsquo;t able to find the password using the wordlists I had. I suppose I need to investigate more techniques and maybe harness my GPU.</p>\n\n<p>Few more things come to my mind for future work:</p>\n\n<ul>\n <li>Are there any other weaknesses in the implementation?</li>\n <li>Could this be integrated into the &ldquo;John the Ripper&rdquo; password cracker?</li></ul>\n\n<h3 id=\"references\">References</h3>\n\n<ul>\n <li>\n  <p><a href=\"https://github.com/quakehead/idea\">The IDEA code that compiles in a modern linux enviornment</a></p></li>\n <li>\n  <p><a href=\"https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm\">The IDEA algorithm</a></p></li></ul>") #f (u . "\n<p>Spoiler alert: I didn&rsquo;t find the password.</p>\n\n<p>Around 2002, I came across a tool that encrypts and decrypts files using the IDEA cipher. <a href=\"https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm\">IDEA</a> was created in 1991 by James Massey Xuejia Lai, and it seems still relatively secure. It&rsquo;s still used in a recent version of opengpg.</p>\n\n<p>I had encrypted few zip files using this, in 2002 and 2003. (Nothing serious, just wanted to try out encrypting things.) However, I forgot the passwords.</p>\n\n<p>Looking at the implementation, it says it uses a maximum of 8 characters for a passphrase, which is about half of IDEA&rsquo;s 128-bit keylength (not counting non-ascii characters.)</p>\n\n<p>It was a tool for DOS in 16-bit mode.</p>\n\n<p>Given this limitation, is bruteforcing a password possible? If I used only lowercase letters for the password, the number of passwords to try would be <code>26^8 = 208,827,064,576</code>, or about 200 billion combinations. Alphanumeric combinations would be <code>(26*2 + 10)^8 = 218,340,105,584,896</code>, or about 218 trillion. Some simple math can lead us to an estimate of the time to go through the search space. It depends on the elements and elements/s.</p>\n\n<p>One challenge with finding the correct decryption password is there&rsquo;s no easy way of making sure we hae the correct password. The way this idea program worked was to only encrypt/decrypt fixed blocks, with no integrity checking. If we decrypt a file with the wrong password, it would output random data. So one way to find the correct password is to find a pattern in the output if we know what the output would contain. Since it was a zip file, a zip file has a known header in the first block (16 bytes).</p>\n\n<p>I modified the main file to read words from a wordlist, decrypt the first block, and test if it&rsquo;s a zip header. Instead of parallizing the solution in C, I wrote simple bash scripts to run it parallelly after splitting the wordlist into 4, the number of cores I have. I was able to process 700k passwords/s. I wasn&rsquo;t able to find the password using the wordlists I had. I suppose I need to investigate more techniques and maybe harness my GPU.</p>\n\n<p>Few more things come to my mind for future work:</p>\n\n<ul>\n <li>Are there any other weaknesses in the implementation?</li>\n <li>Could this be integrated into the &ldquo;John the Ripper&rdquo; password cracker?</li></ul>\n\n<h3 id=\"references\">References</h3>\n\n<ul>\n <li>\n  <p><a href=\"https://github.com/quakehead/idea\">The IDEA code that compiles in a modern linux enviornment</a></p></li>\n <li>\n  <p><a href=\"https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm\">The IDEA algorithm</a></p></li></ul>"))))